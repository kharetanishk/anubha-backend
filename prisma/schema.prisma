generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
} 

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum BookingProgress {
  USER_DETAILS
  RECALL
  SLOT
  PAYMENT
}

enum AppointmentMode {
  IN_PERSON
  ONLINE
}

enum StorageProvider {
  CLOUDINARY
  S3
  LOCAL
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum SleepQuality {
  NORMAL
  IRREGULAR
  DISTURBED
  INSOMNIA
}

enum FoodPreference {
  VEG
  NON_VEG
  EGG_VEG
}

enum BowelMovement {
  NORMAL
  CONSTIPATION
  DIARRHEA
  IRREGULAR
}

enum MealType {
  PRE_WAKEUP
  BREAKFAST
  MID_MEAL
  LUNCH
  MID_EVENING
  DINNER
  OTHER
}

enum DoctorFieldType {
  TEXT
  NUMBER
  SELECT
  MULTISELECT
  RADIO
  BOOLEAN
  DATE
  TIME
  TEXTAREA
}

enum FormSectionType {
  PERSONAL_INFO
  FOOD_RECALL_24H
  WEEKEND_DIET
  QUESTIONNAIRE
  FOOD_FREQUENCY
  HEALTH_PROFILE
  DIET_PRESCRIBED
}

enum MealPeriod {
  MORNING_INTAKE
  BREAKFAST
  MID_MORNING
  LUNCH
  MID_DAY
  EVENING_SNACK
  DINNER
}

enum AttachmentCategory {
  DIET_CHART
  LAB_REPORT
  PRESCRIPTION
  IMAGE
  DOCUMENT
  OTHER
}

// ============================================
// AUTH / CORE MODELS
// ============================================
model User {
  id            String           @id @default(uuid())
  name          String
  email         String?          @unique
  phone         String           @unique
  role          Role             @default(USER)
  patients      PatientDetials[]
  appointments  Appointment[]
  refreshTokens RefreshToken[]
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  isArchived    Boolean          @default(false)
  archivedAt    DateTime?

  @@index([phone])
  @@index([email])
  @@index([isArchived])
}

model OTP {
  id        String   @id @default(uuid())
  phone     String
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([phone])
  @@index([expiresAt])
  @@index([phone, expiresAt]) // Composite index for efficient cleanup queries
  // Note: Multiple OTPs per phone allowed (for retry scenarios)
  // Race condition handled at application level with atomic delete+create
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String?
  adminId   String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  admin     Admin?   @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([adminId])
  @@index([expiresAt])
}

model Admin {
  id                String              @id @default(uuid())
  name              String
  email             String              @unique
  phone             String              @unique
  slots             Slot[]
  doctorDaysOff     DoctorDayOff[]
  appointments      Appointment[]       @relation("DoctorAppointments")
  refreshTokens     RefreshToken[]
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  isArchived        Boolean             @default(false)
  archivedAt        DateTime?
  DoctorFormSession DoctorFormSession[]

  @@index([email])
  @@index([phone])
  @@index([isArchived])
}

// ============================================
// PATIENT / RECALL / FILES
// ============================================
model PatientDetials {
  id                  String              @id @default(uuid())
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String
  name                String
  phone               String
  gender              Gender
  email               String
  dateOfBirth         DateTime
  age                 Int
  address             String
  weight              Float
  height              Float
  neck                Float?
  waist               Float?
  hip                 Float?
  // Detailed measurements (for weight loss plan)
  chest               Float?
  chestFemale         Float?
  normalChestLung     Float?
  expandedChestLungs  Float?
  arms                Float?
  forearms            Float?
  wrist               Float?
  abdomenUpper        Float?
  abdomenLower        Float?
  thighUpper          Float?
  thighLower          Float?
  calf                Float?
  ankle               Float?
  medicalHistory      String?
  appointmentConcerns String?
  files               File[]
  bowelMovement       BowelMovement
  foodPreference      FoodPreference
  allergic            String?
  dailyFoodIntake     String?
  dailyWaterIntake    Int
  wakeUpTime          String
  sleepTime           String
  sleepQuality        SleepQuality
  recalls             Recall[]            @relation("PatientRecalls")
  appointments        Appointment[]
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  isArchived          Boolean             @default(false)
  archivedAt          DateTime?
  DoctorFormSession   DoctorFormSession[]

  @@unique([userId, name])
  @@index([userId])
  @@index([phone])
  @@index([email])
  @@index([isArchived])
}

model Recall {
  id            String         @id @default(uuid())
  patient       PatientDetials @relation("PatientRecalls", fields: [patientId], references: [id], onDelete: Cascade)
  patientId     String
  appointment   Appointment?   @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId String?        @unique
  notes         String?
  entries       RecallEntry[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  isArchived    Boolean        @default(false)
  archivedAt    DateTime?

  @@index([patientId])
  @@index([appointmentId])
  @@index([isArchived])
}

model RecallEntry {
  id        String   @id @default(uuid())
  recall    Recall   @relation(fields: [recallId], references: [id], onDelete: Cascade)
  recallId  String
  mealType  MealType
  time      String
  foodItem  String
  quantity  String
  notes     String?
  createdAt DateTime @default(now())

  @@index([recallId, mealType])
  @@index([mealType])
}

model File {
  id          String          @id @default(uuid())
  url         String
  publicId    String
  fileName    String
  mimeType    String
  sizeInBytes Int
  provider    StorageProvider @default(CLOUDINARY)
  patient     PatientDetials? @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId   String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  isArchived  Boolean         @default(false)
  archivedAt  DateTime?

  @@index([patientId])
  @@index([isArchived])
}

// ============================================
// SLOTS / APPOINTMENTS / DAYS OFF
// ============================================
model Slot {
  id          String          @id @default(uuid())
  admin       Admin           @relation(fields: [adminId], references: [id], onDelete: Cascade)
  adminId     String
  startAt     DateTime
  endAt       DateTime
  mode        AppointmentMode
  isBooked    Boolean         @default(false)
  appointments Appointment[]  // Changed to one-to-many: multiple appointments can reference same slot
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  isArchived  Boolean         @default(false)
  archivedAt  DateTime?

  @@unique([adminId, startAt])
  @@index([adminId, startAt, isBooked])
  @@index([startAt, isBooked])
  @@index([isArchived])
}

model Appointment {
  id                      String              @id @default(uuid())
  startAt                 DateTime
  endAt                   DateTime
  status                  AppointmentStatus   @default(PENDING)
  bookingProgress         BookingProgress?    // Track where user left off
  user                    User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                  String
  doctor                  Admin               @relation("DoctorAppointments", fields: [doctorId], references: [id], onDelete: Restrict)
  doctorId                String
  patient                 PatientDetials      @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId               String
  slot                    Slot?               @relation(fields: [slotId], references: [id], onDelete: SetNull)
  slotId                  String?
  paymentId               String?
  paymentStatus           String              @default("PENDING")
  amount                  Int?
  notes                   String?
  reminderSent            Boolean             @default(false)
  shortNoticeReminderSent Boolean             @default(false)
  reminderTime            DateTime?           // When to send reminder (slotTime - 1 hour)
  planSlug                String
  planName                String
  planPrice               Int
  planDuration            String
  planPackageName         String?
  mode                    AppointmentMode
  doctorNotes             DoctorNotes?
  recall                  Recall?
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  isArchived              Boolean             @default(false)
  archivedAt              DateTime?
  DoctorFormSession       DoctorFormSession[]
  Reminder                Reminder[]
  MessageLog              MessageLog[]

  @@index([startAt])
  @@index([doctorId, startAt])
  @@index([patientId, startAt])
  @@index([status, startAt])
  @@index([bookingProgress]) // Frequently queried for booking flow
  @@index([status, bookingProgress]) // Common query pattern: PENDING appointments by progress
  @@index([slotId, status]) // Prevent multiple PENDING appointments per slot
  @@index([reminderTime, reminderSent]) // For cron job to find appointments needing reminders
  @@index([isArchived])
  // Note: Partial unique constraint (only one PENDING per slot) added via migration
  // See prisma/migrations/add_partial_unique_constraint.sql
}

model DoctorDayOff {
  id         String    @id @default(uuid())
  admin      Admin     @relation(fields: [adminId], references: [id], onDelete: Cascade)
  adminId    String
  date       DateTime
  reason     String?
  createdAt  DateTime  @default(now())
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@unique([adminId, date])
  @@index([date])
  @@index([adminId, date])
  @@index([isArchived])
}

model WebhookEvent {
  id        String   @id @default(uuid())
  eventId   String   @unique
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// ============================================
// HYBRID DOCTOR NOTES ARCHITECTURE
// ============================================

model DoctorNotes {
  id            String      @id @default(cuid())
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId String      @unique

  // Form versioning - allows schema evolution without migrations
  formVersion String @default("1.0.0")

  // Status tracking
  isDraft     Boolean   @default(true)
  isCompleted Boolean   @default(false)
  completedAt DateTime?
  submittedAt DateTime? // When doctor finalized/submitted the note

  // General notes/remarks at top level
  notes String? @db.Text

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // Admin/Doctor ID
  updatedBy String? // Admin/Doctor ID

  // Soft delete
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  // HYBRID APPROACH: Structured + JSONB
  // Core structured fields (rarely change)
  personalHistory         String?   @db.Text
  reasonForJoiningProgram String?   @db.Text
  ethnicity               String?
  joiningDate             DateTime?
  expiryDate              DateTime?
  dietPrescriptionDate    DateTime?
  durationOfDiet          String?
  maritalStatus           String?
  numberOfChildren        Int?
  dietPreference          String?
  wakeupTime              String?
  bedTime                 String?
  dayNap                  String?
  workoutTiming           String?
  workoutType             String?

  // JSONB for flexible, evolving form sections (explicit PostgreSQL JSONB)
  formData Json? @db.JsonB // All form sections in flexible JSON structure

  // Cached analytics data (precomputed values for performance)
  analyticsData Json? @db.JsonB // Precomputed analytics, summaries, etc.

  // Structured relations for queryable, repeated patterns
  mealEntries          MealEntry[]
  foodFrequencyItems   FoodFrequencyItem[]
  healthConditions     HealthCondition[]
  questionnaireAnswers QuestionnaireAnswer[]

  // File attachments
  attachments DoctorNoteAttachment[]

  @@index([appointmentId])
  @@index([createdAt])
  @@index([formVersion])
  @@index([isCompleted, submittedAt])
  @@index([isDraft])
  @@index([isArchived, archivedAt])
  @@index([createdBy])
  @@index([submittedAt])
  // PostgreSQL JSONB GIN indexes (created via raw SQL - see POSTGRESQL_OPTIMIZATIONS.sql)
  @@map("doctor_notes")
}

// ============================================
// STRUCTURED MODELS FOR REPEATED PATTERNS
// ============================================

model MealEntry {
  id            String      @id @default(cuid())
  doctorNotesId String
  doctorNotes   DoctorNotes @relation(fields: [doctorNotesId], references: [id], onDelete: Cascade)

  mealPeriod MealPeriod // MORNING_INTAKE, BREAKFAST, LUNCH, etc.
  time       String?

  // Flexible food items storage (explicit PostgreSQL JSONB)
  foodItems Json @db.JsonB // Array of { name, quantity, checked, notes }

  // Common fields
  waterIntake Int?
  medicines   String? @db.Text
  notes       String? @db.Text

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@unique([doctorNotesId, mealPeriod]) // One entry per meal period per note
  @@index([doctorNotesId, mealPeriod])
  @@index([mealPeriod])
  @@index([doctorNotesId])
  @@index([isArchived])
}

model FoodFrequencyItem {
  id            String      @id @default(cuid())
  doctorNotesId String
  doctorNotes   DoctorNotes @relation(fields: [doctorNotesId], references: [id], onDelete: Cascade)

  category String // "NonVeg", "Packaged", "Sweetener", "Drink", "Lifestyle", "HealthyFood", etc.
  itemName String // "Poha", "Fish", "Sugar", "Tea", etc. - DYNAMIC!

  checked   Boolean @default(false)
  quantity  String? // Flexible quantity format
  frequency String? // "Daily", "Weekly", "Monthly", etc.

  // Flexible metadata for item-specific data (explicit PostgreSQL JSONB)
  metadata Json? @db.JsonB // { prepType, qtyPieces, qtyTspTbsp, etc. }

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@unique([doctorNotesId, category, itemName]) // Prevent duplicates
  @@index([doctorNotesId, category])
  @@index([category, itemName])
  @@index([doctorNotesId])
  @@index([checked, category])
  @@index([isArchived])
}

model HealthCondition {
  id            String      @id @default(cuid())
  doctorNotesId String
  doctorNotes   DoctorNotes @relation(fields: [doctorNotesId], references: [id], onDelete: Cascade)

  conditionName String // "High B.P", "Diabetes", etc. - DYNAMIC!
  hasCondition  String // "Yes" or "No"
  notes         String? @db.Text // Additional details

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@unique([doctorNotesId, conditionName]) // Prevent duplicates
  @@index([doctorNotesId])
  @@index([conditionName, hasCondition])
  @@index([hasCondition])
  @@index([isArchived])
}

model QuestionnaireAnswer {
  id            String      @id @default(cuid())
  doctorNotesId String
  doctorNotes   DoctorNotes @relation(fields: [doctorNotesId], references: [id], onDelete: Cascade)

  questionKey String // "foodAllergies", "eatingSpeed", etc. - DYNAMIC!
  answer      String? @db.Text // Answer value
  answerType  String? // "text", "select", "radio", "boolean", etc.

  // For "Other" options
  otherValue String? @db.Text

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@unique([doctorNotesId, questionKey]) // One answer per question
  @@index([doctorNotesId, questionKey])
  @@index([questionKey])
  @@index([doctorNotesId])
  @@index([isArchived])
}

model DoctorNoteAttachment {
  id            String      @id @default(uuid())
  doctorNotesId String
  doctorNotes   DoctorNotes @relation(fields: [doctorNotesId], references: [id], onDelete: Cascade)

  fileName    String
  filePath    String // Path to uploaded file
  fileUrl     String? // Public URL if stored in cloud
  mimeType    String
  sizeInBytes Int
  provider    StorageProvider @default(CLOUDINARY)

  fileCategory AttachmentCategory @default(OTHER) // Grouping attachments
  section      String? // Which section this belongs to (e.g., "DietPrescribed")

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  @@index([doctorNotesId])
  @@index([doctorNotesId, fileCategory])
  @@index([fileCategory])
  @@index([section])
  @@index([isArchived])
}

// ============================================
// FORM SCHEMA VERSIONING
// ============================================

model FormSchema {
  id      String @id @default(uuid())
  version String @unique // "1.0.0", "1.1.0", etc.

  // JSON schema definition of form structure (explicit PostgreSQL JSONB)
  schema Json @db.JsonB // Full form schema definition

  // Metadata
  description String?   @db.Text
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  isArchived  Boolean   @default(false)
  archivedAt  DateTime?

  @@index([version, isActive])
  @@index([isActive])
  @@index([isArchived])
}

// ============================================
// ADDITIONAL MODELS
// ============================================
model DoctorFormSession {
  id            String          @id @default(uuid())
  patient       PatientDetials? @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId     String?
  admin         Admin?          @relation(fields: [adminId], references: [id], onDelete: Cascade)
  adminId       String?
  appointment   Appointment?    @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  isArchived    Boolean         @default(false)
  archivedAt    DateTime?

  @@index([patientId])
  @@index([adminId])
  @@index([appointmentId])
  @@index([isArchived])
}

model Reminder {
  id            String      @id @default(uuid())
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  isArchived    Boolean     @default(false)
  archivedAt    DateTime?

  @@index([appointmentId])
  @@index([isArchived])
}

model MessageLog {
  id            String      @id @default(uuid())
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  isArchived    Boolean     @default(false)
  archivedAt    DateTime?

  @@index([appointmentId])
  @@index([isArchived])
}
